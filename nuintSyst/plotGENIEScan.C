#include "TH1.h"#include "TGraph.h"#include "TEfficiency.h"#include "TH2.h"#include "TF1.h"#include "TROOT.h"#include "TStyle.h"#include "TMath.h"#include "TFile.h"#include "TCanvas.h"#include "TPad.h"#include "TGraphErrors.h"#include "TVectorD.h"#include "TTimeStamp.h"#include <fstream>#include "TMinuit.h"#include "TString.h"#include <vector>#include <string.h>#include "TLatex.h"#include "TPaveStats.h"#include "TDatime.h"#include "TColor.h"#include "TProfile.h"#include "TProfile2D.h"#include <TH2.h>#include <TStyle.h>#include <TCanvas.h>#include "TPrincipal.h"#include "TDecompChol.h"#include "TEfficiency.h"#include "RooUnfoldResponse.h"#include "RooUnfoldBayes.h"#include <iomanip>struct DialScore {    TString name;    double score;};void plotGENIEScan(){gROOT->LoadMacro("protoDUNEStyle.C");gROOT->SetStyle("protoDUNEStyle");gROOT->ForceStyle();gStyle->SetTitleX(0.35);gStyle->SetOptFit(111);float NAr=2.825846e+28;TCanvas c1=TCanvas();TLatex tL;    tL.SetNDC();    tL.DrawLatex(0.20,0.94,"#bf{DUNE:ND-LAr 2x2}");TFile fPurity("testScan.root");TFile fFakeData("testSPINEPart2.root");TFile *rwTemplate =    new TFile("MiniRun65Nusyst100Universes/MiniRun6.5_1E19_RHC.nuweights.0000000.nusyst.root");TTree* rw_chain2 = (TTree*)rwTemplate->Get("SystWeights");std::vector<TString> dialNames;std::map<TString, Double_t*> dialBuffers;std::vector<TProfile*> cosLProfiles;std::vector<TProfile*> multProfiles;// Discover dials onceTObjArray* branches = rw_chain2->GetListOfBranches();for (int i = 0; i < branches->GetEntries(); ++i) {    TBranch* br = (TBranch*)branches->At(i);    TString name = br->GetName();    if (name.BeginsWith("EventID") || name.BeginsWith("genieIdx"))        continue;    /*    if (name.BeginsWith("FSIReweight")) {        continue;  // skip this entry    }    if (name.EndsWith("VariationResponse")) {        continue;  // skip this entry    }    */    dialNames.push_back(name);    // allocate buffer once    dialBuffers[name] = new Double_t[100];    // create profile once    TProfile* histCosL=(TProfile*)fPurity.Get(Form("trueCosL_%s",name.Data()));    cosLProfiles.push_back(histCosL);        // create profile once       TProfile* histMult =(TProfile*)fPurity.Get(Form("true_multTrkOnly_%s",name.Data()));    multProfiles.push_back(histMult);}    std::vector<DialScore> scores;    for (TProfile* p : cosLProfiles) {        int nb = p->GetNbinsX();        double sumErr2 = 0.0;        int nused = 0;        for (int b = 1; b <= nb; ++b) {            double err = p->GetBinError(b);            if (err <= 0) continue;            sumErr2 += (err * err);            nused++;        }        double score = (nused > 0)            ? TMath::Sqrt(sumErr2 / nused)            : 0.0;        scores.push_back({p->GetName(), score});    }    // ------------------------------------------------------------    // Sort    // ------------------------------------------------------------    int topN = 100;    std::sort(scores.begin(), scores.end(),              [](const DialScore& a, const DialScore& b) {                  return a.score > b.score;              });    // ------------------------------------------------------------    // Write ranking quietly    // ------------------------------------------------------------    TFile fout("dial_profile_ranking.root", "RECREATE");    TTree rank("DialRanking", "Dial ranking by RMS bin error");    TString dial;    double score;    rank.Branch("dial", &dial);    rank.Branch("score", &score);    for (int i = 0; i < std::min(topN, (int)scores.size()); ++i) {        dial  = scores[i].name;        score = scores[i].score;        rank.Fill();    }    rank.Write();    fout.Close();}