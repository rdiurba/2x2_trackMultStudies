#include "duneanaobj/StandardRecord/Proxy/SRProxy.h"#include "CAFAna/Core/SpectrumLoader.h"#include "CAFAna/Core/Spectrum.h"#include "CAFAna/Core/Binning.h"#include "CAFAna/Core/Var.h"#include "CAFAna/Core/Cut.h"#include "CAFAna/Core/HistAxis.h"#include "TCanvas.h"#include "TH1.h"#include "TH2.h"#include "TPad.h"#include "TLegend.h"#include "TMath.h"#include <iostream>using namespace ana;// Make a few basic spectra from the cafs// Reconstructed //    - One with Interaction Level vars/cuts//    - One with particle-level vars/cuts// Truth //   - True interaction Level Vars/Cuts//   - True particles Level Vars/Cuts  const auto beam_dir = TVector3(0.0, -0.05836, 1.0); //(-3.34 degrees in Y)  double beam_x = 0;  double beam_y = -0.05836 / TMath::Sqrt(0.05836 * 0.05836 + 1);  double beam_z = 1.0 / TMath::Sqrt(0.05836 * 0.05836 + 1);void 2x2_ccinc(){  // Sample ND-LAr file  const std::string fname = "/global/cfs/cdirs/dune/www/data/2x2/simulation/productions/MiniRun6.4_1E19_RHC/MiniRun6.4_1E19_RHC.caf_v2/CAF.flat/0000000/MiniRun6.4_1E19_RHC.caf_v2.*flat.root";  SpectrumLoader loader(fname);  /////////////////////////////////////////////////////////////////  // Reco-Particles (SRRecoParticleProxy)  level vars and cuts  const RecoPartVar kRecoParticleEnergy = SIMPLEPARTVAR(E);  // Define axes for the spectra we'll make  const RecoPartHistAxis axEnergy("Muon energy (GeV)", Binning::Simple(50, 0, 1), kRecoParticleEnergy);  // Select particles that have a pdg of muon,   const RecoPartCut kIsMuon([](const caf::SRRecoParticleProxy* sr)                      {                    double endMnvTrack=-999;                    bool isMu=false;                    const caf::SRProxy * top = part->Ancestor<caf::SRProxy>();                    int pdg = sr->pdg;                    // Loop over primary tracks                    if (!(abs(pdg) == 2212 || abs(pdg) == 13 || abs(pdg) == 211 ||                         abs(pdg) == 321)) return isMu                    if (!sr->primary) return isMu;                    if (!sr->end.z<62) return isMu;                    const caf::SRProxy * top = sr->Ancestor<caf::SRProxy>();                    for(int k=0; k<top->nd.trkmatch.extrap.size(); k++){                    if (top->nd.trkmatch.extrap[k].larid.reco!=1 || top->nd.trkmatch.extrap[k].angdispl<0.99) continue;                    int i=top->nd.trkmatch.extrap[k].minervaid.ixn; int j=top->nd.trkmatch.extrap[k].minervaid.idx;                    if (endMnvTrack<top->nd.minerva.ixn[i].tracks[j].end.z) endMnvTrack=top->nd.minerva.ixn[i].tracks[j].end.z;                    }                                        for(int k=0; k<top->nd.trkmatch.extrap.size(); k++){                    if (top->nd.trkmatch.extrap[k].larid.reco!=1) continue;                                         int index=top->nd.trkmatch.extrap[k].larid.idx;                    int ixn=top->nd.trkmatch.extrap[k].larid.ixn;                    if (top->nd.lar.dlp[ixn].tracks[index].start.z!=sr->start.z || top->nd.lar.dlp[ixn].tracks[index].end.z!=sr->end.z) continue;                        int i=top->nd.trkmatch.extrap[k].minervaid.ixn; int j=top->nd.trkmatch.extrap[k].minervaid.idx;                    if (endMnvTrack==top->nd.minerva.ixn[i].tracks[j].end.z) isMu==true;                    }                    return isMu;                                                });  /////////////////////////////////////////////////////////////////  // Interaction level (SRInteractionProxy)  Simple vars   const Var kVtxX = SIMPLEVAR(vtx.x);  //  we can also write vars with additional logic/operations  const Var kVtxZ([](const caf::SRInteractionProxy* sr)                      {                                                double z = sr-> vtx.z;//-1300;                        // you could do more operations here                        return z;                      });    const RecoPartVar kRecoMuCosL([](const  caf::SRRecoParticleProxy * part) -> float    {      float ret = -999.;      double dX = (part->end.x - part->start.x);      double dY = (part->end.y - part->start.y);      double dZ = (part->end.z - part->start.z);      double length = TMath::Sqrt(dX * dX + dY * dY + dZ * dZ);      double dirX = dX / length;      double dirY = dY / length;      double dirZ = dZ / length;            double cosLReco =          dirX * beam_x + dirY * beam_y + dirZ * beam_z;      ret =  cosLReco;      return ret;        });  // Histaxis with interaction level variables  // Note you can setup a 2D axis, you can directly write simple vars here  const HistAxis vtxPosition( "x(cm)", Binning::Simple(70,-70,70), kVtxX,                               "z(cm)", Binning::Simple(70,-70,70), SIMPLEVAR(vtx.z)); //or kVtxZ  // A simple selection cut at the level of vertices: i.e. containment  const Cut kContainedVertex([](const caf::SRInteractionProxy* sr)                      {                        double x = sr->vtx.x;                        double y = sr->vtx.y;                        double z = sr->vtx.z;                        bool cont =  abs(x)<59 &&                                      abs(x)>5 &&                                      abs(y)<57 &&                                     abs(z)>59.5 &&                                      abs(z)<5 ;                        return cont;                      });      const Cut kCCnuMuCandidate([](const caf::SRInteractionProxy* sr)                      {                double dotProductCos=-999                for (long unsigned npart = 0; npart < sr->part.dlp.size(); npart++) {                    int pdg = sr->part.dlp[npart].pdg;                    // Loop over primary tracks                    if (!(abs(pdg) == 2212 || abs(pdg) == 13 || abs(pdg) == 211 ||                         abs(pdg) == 321)) continue;                    if (!sr->part.dlp[npart].primary) continue;                    if (!sr->part.dlp[npart].end.z<62) continue;                    const caf::SRProxy * top = sr->Ancestor<caf::SRProxy>();                    for(int k=0; k<top->nd.trkmatch.extrap.size(); k++){                    if (top->nd.trkmatch.extrap[k].larid.reco!=1) continue;                    int index=top->nd.trkmatch.extrap[k].larid.idx;                    int ixn=top->nd.trkmatch.extrap[k].larid.ixn;                    if (top->nd.lar.dlp[ixn].tracks[index].start.z!=sr->part.dlp[npart].start.z || top->nd.lar.dlp[ixn].tracks[index].end.z!=sr->part.dlp[npart].end.z) continue;                    if (dotProductCos<top->nd.trkmatch.extrap[k].angdipsl) dotProductCos=top->nd.trkmatch.extrap[k].angdipsl;                    }                   }                bool match=false;                if (dotProductCos>0.99) match=true;                return match;                      });  /////////////////////////////////////////////////////////////////   //  ~~~~**** now actually make some histograms  *****~~~~  // we use kNoCut at interactions level, meaning no selection on vertices, then with containment  // You can select RecoType::kDLP,kPandora at vtx/interaction level and kPIDA as well for particles  Spectrum sEnergyMuon(     loader.Interactions(RecoType::kDLP)[kNoCut].RecoParticles(      RecoType::kDLP)[kIsMuon], axEnergy);  Spectrum sEnergyMuonCont( loader.Interactions(RecoType::kDLP)[kContainedVertex && kNuMuCCCandidate].RecoParticles(RecoType::kDLP)[kIsMuon], axEnergy);  // Interaction level vars  Spectrum sVtxPositionAll( loader.Interactions(RecoType::kDLP)[kNoCut], vtxPosition);  Spectrum sVtxPositionCont(loader.Interactions(RecoType::kDLP)[kContainedVertex && kCCnuMuCandidate], vtxPosition);  // You need the histaxis to match the Cut level (i.e: the next one will not work becausePosition is an SRInteraction entry  // but your spectrumLoader points to entries from SRRecoParticle  // Spectrum sVtxPositionCont(loader.Interactions(RecoType::kDLP)[kContainedVertex].RecoParticles(RecoType::kDLP)[kIsMuon], vtxPosition);     /////////////////////////////////////////////////////////////////  const TruthVar kTrueId([](const caf::SRTrueInteractionProxy* nu){return nu->id;});  const TruthCut kIsTrueNuMuCC ([](const caf::SRTrueInteractionProxy* nu){                        int pdg = nu->pdg;                         return (pdg==14 && nu->cc==true && nu->targetPDG==1000180400);    }); const TruthCut kTruthContainedVertex ([](const caf::SRTrueInteractionProxy* nu){                        double x = nu->vtx.x;                        double y = nu->vtx.y;                        double z = nu->vtx.z;                        bool cont =  abs(x)<59 &&                                      abs(x)>5 &&                                      abs(y)<57 &&                                     abs(z)>59.5 &&                                      abs(z)<5 ;                                         return cont;    }); const TruthCut kTruthSignalDefinition ([](const caf::SRTrueInteractionProxy* nu){                        double x = nu->vtx.x;                        double y = nu->vtx.y;                        double z = nu->vtx.z;                        bool cont =  abs(x)<59 &&                                      abs(x)>5 &&                                      abs(y)<57 &&                                     abs(z)>59.5 &&                                      abs(z)<5 ;                                         return cont;    });// some truth variables    const TruthPartVar kTruthMuCosL([](const  caf::SRTrueParticleProxy * part) -> float    {      float ret = -999.;        double dPX = part->p.px;        double dPY = part->p.py;        double dPZ = part->p.pz;        double lengthP =        TMath::Sqrt(p.px * p.px + p.py * p.py + p.pz * p.pz);      double dir_x = dPX / lengthP;      double dir_y = dPY / lengthP;      double dir_z = dPZ / lengthP;      cosL = dir_x * beam_x + dir_y * beam_y + dir_z * beam_z;      ret =  cosL;      return ret;        });